..
    Copyright (C) 2012 Adrian Serio
    Copyright (C) 2012 Vinay C Amatya
    Copyright (C) 2015 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

.. _tutorials_fibonacci:

=========
Fibonacci
=========

The Fibonacci sequence is a sequence of numbers starting with 0 and 1 where
every subsequent number is the sum of the previous two numbers. In this example,
we will use |hpx| to calculate the value of the n-th element of the Fibonacci
sequence. In order to compute this problem in parallel, we will use a facility
known as a future.

As shown in the :numref:`future_schematics` below, a future encapsulates a
delayed computation. It acts as a proxy for a result initially not known, most
of the time because the computation of the result has not completed yet. The
future synchronizes the access of this value by optionally suspending any
|hpx|-threads requesting the result until the value is available. When a future
is created, it spawns a new |hpx|-thread (either remotely with a parcel or
locally by placing it into the thread queue) which, when run, will execute the
action associated with the future. The arguments of the action are bound when
the future is created.

.. _future_schematics:

.. figure:: /_static/images/future_schematics.png

   Schematic of a future execution.

Once the action has finished executing, a write operation is performed on the
future. The write operation marks the future as completed, and optionally stores
data returned by the action. When the result of the delayed computation is
needed, a read operation is performed on the future. If the future's action
hasn't completed when a read operation is performed on it, the reader
|hpx|-thread is suspended until the future is ready. The future facility allows
|hpx| to schedule work early in a program so that when the function value is
needed it will already be calculated and available. We use this property in our
Fibonacci example below to enable its parallel execution.

Setup
=====

The source code for this example can be found here:
:download:`fibonacci.cpp <../../examples/quickstart/fibonacci.cpp>`.

To compile this program, go to your |hpx| build directory (see
:ref:`running_on_batch_systems` for information on configuring and building
|hpx|) and enter:

.. code-block:: bash

   make examples.quickstart.fibonacci

To run the program type:

.. code-block:: bash

   ./bin/fibonacci

This should print (time should be approximate):

.. code-block:: text

    fibonacci(10) == 55
    elapsed time: 0.00186288 [s]

This run used the default settings, which calculate the tenth element of the
Fibonacci sequence. To declare which Fibonacci value you want to calculate, use
the ``--n-value`` option. Additionally you can use the :option:`--hpx:threads`
option to declare how many OS-threads you wish to use when running the program.
For instance, running:

.. code-block:: bash

   ./bin/fibonacci --n-value 20 --hpx:threads 4

Will yield:

.. code-block:: text

   fibonacci(20) == 6765
   elapsed time: 0.233827 [s]

Walkthrough
===========

Now that you have compiled and run the code, let's look at how the code works.
Since this code is written in C++, we will begin with the ``main()`` function.
Here you can see that in |hpx|, ``main()`` is only used to initialize the
runtime system. It is important to note that application-specific command line
options are defined here. |hpx| uses |boost_program_options|_ for command line
processing. You can see that our programs ``--n-value`` option is set by calling
the ``add_options()`` method on an instance of
``boost::program_options::options_description``. The default value of the
variable is set to 10. This is why when we ran the program for the first time
without using the ``--n-value`` option the program returned the 10th value of
the Fibonacci sequence. The constructor argument of the description is the text
that appears when a user uses the :option:`--help` option to see what command
line options are available. ``HPX_APPLICATION_STRING`` is a macro that expands
to a string constant containing the name of the |hpx| application currently
being compiled.

In |hpx| ``main()`` is used to initialize the runtime system and pass the
command line arguments to the program. If you wish to add command line options
to your program you would add them here using the instance of the Boost class
``options_description``, and invoking the public member function
``.add_options()`` (see |boost_doc|_ or the :ref:`tutorials_fibonacci` for more
details). :cpp:func:`hpx::init()` calls ``hpx_main()`` after setting up |hpx|,
which is where the logic of our program is encoded.

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :lines: 77-91

The :cpp:func:`hpx::init` function in ``main()`` starts the runtime system, and
invokes ``hpx_main()`` as the first |hpx|-thread. Below we can see that the
basic program is simple. The command line option ``--n-value`` is read in, a
timer (:cpp:class:`hpx::util::high_resolution_timer`) is set up to record the time
it takes to do the computation, the fibonacci action is invoked synchronously,
and the answer is printed out.

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :lines: 54-72

Upon a closer look we see that we've created a ``std::uint64_t`` to store the
result of invoking our ``fibonacci_action`` ['fib]. This action will launch
synchronously ( as the work done inside of the action will be asynchronous
itself) and return the result of the fibonacci sequence. But wait, what is an
action? And what is this ``fibonacci_action``? For starters, an action is a
wrapper for a function. By wrapping functions, |hpx| can send packets of work to
different processing units. These vehicles allow users to calculate work now,
later, or on certain nodes. The first argument to our action is the location
where the action should be run. In this case, we just want to run the action on
the machine that we are currently on, so we use :cpp:func:`hpx::find_here` that
we wish to calculate. To further understand this we turn to the code to find
where ``fibonacci_action`` was defined:

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :lines: 20-25

A plain action is the most basic form of action. Plain actions wrap simple
global functions which are not associated with any particular object (we will
discuss other types of actions in :ref:`tutorials_accumulator`). In this block
of code the function ``fibonacci()`` is declared. After the declaration, the
function is wrapped in an action in the declaration [macroref HPX_PLAIN_ACTION
``HPX_PLAIN_ACTION``]. This function takes two arguments: the name of the
function that is to be wrapped and the name of the action that you are creating.

This picture should now start making sense. The function ``fibonacci()`` is
wrapped in an action ``fibonacci_action``, which was run synchronously but
created asynchronous work, then returns a ``std::uint64_t`` representing the
result of the function ``fibonacci()``. Now, let's look at the function
``fibonacci()``:

.. literalinclude:: ../../examples/quickstart/fibonacci.cpp
   :lines: 30-49

This block of code is much more straightforward. First, ``if (n < 2)``, meaning
n is 0 or 1, then we return 0 or 1 (recall the first element of the Fibonacci
sequence is 0 and the second is 1). If n is larger than 1, then we spawn two
futures, ``n1`` and ``n2``. Each of these futures represents an asynchronous,
recursive call to ``fibonacci()``. After we've created both futures, we wait for
both of them to finish computing, and then we add them together, and return that
value as our result. The recursive call tree will continue until n is equal to 0
or 1, at which point the value can be returned because it is implicitly known.
When this termination condition is reached, the futures can then be added up,
producing the n-th value of the Fibonacci sequence.
